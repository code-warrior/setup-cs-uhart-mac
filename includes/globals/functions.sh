#!/bin/bash

#
# If colors.sh (-e)xists, then source it.
#
if [[ -e ./includes/globals/colors.sh ]]; then
   source ./includes/globals/colors.sh
else
   printf "The file colors.sh does not exist. This script requires it. Exiting...\n"

   exit 1
fi

#
# Required by the “print_msg” function below.
#
function print_error_msg () {
    printf "%s \n" "${BG_RED}${WHITE}${BOLD} ERROR: In addition to ${RESET}${BG_WHITE}${BLACK} $1 ${RESET}${BG_RED}${WHITE}${BOLD}, the string you would like  ${RESET}${BG_WHITE}${BLACK} ${FUNCNAME[0]} ${RESET}${BG_RED}${WHITE}${BOLD} to render is required as the second argument. "\
            " For example, ${RESET}${BG_WHITE}${BLACK} print_msg \"$1\" \"Content here.\"" "${RESET}"
}

#
# Example usage:
#    print_msg "log" "The procedure has been carried out successfully.
#    print_msg "warn" "Although not fatal, an error was generated by the previous command."
#    print_msg "error" "A required file was not found. Thus, exiting..."
#
function print_msg () {
   # Enable (-s) case-insensitive (nocasematch) pattern matching.
   # (https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html)
   shopt -s nocasematch

   # Process the first argument...
   case "$1" in
      "log" )
         # then check the second argument, starting by verifying that it’s got a length greater than 0
         if [[ -n "$2" ]]; then
            printf "%s > %s %s\n" "${BG_WHITE}${BLACK}${BOLD}" "$2" "${RESET}"
         else
            print_error_msg "$1"
         fi
         ;;

      "warn" )
         # then check the second argument, starting by verifying that it’s got a length greater than 0
         if [[ -n "$2" ]]; then
            printf "%s \n" "${BG_YELLOW}${BLACK}${BOLD} > $2 ${RESET}"
         else
            print_error_msg "$1"
         fi
         ;;

      "error" )
         # then check the second argument, starting by verifying that it’s got a length greater than 0
         if [[ -n "$2" ]]; then
            printf "%s \n" "${BG_RED}${BLACK}${BOLD} > $2 ${RESET}"
         else
            print_error_msg "$1"
         fi
         ;;

      # Handle the case where the first argument is empty or isn’t one of “log”, “warn”, or ”error”.
      "" | * )
         printf "%s \n" "${BG_RED}${WHITE}${BOLD} ERROR: The function ${RESET}${BG_WHITE}${BLACK} ${FUNCNAME[0]} ${RESET}${BG_RED}${WHITE}${BOLD} requires two arguments: log, warn, or error as its first, and the string you’d "\
         " like to render as its second. For example, ${RESET}${BG_WHITE}${BLACK} print_msg \"log\" \"Content here.\"" "${RESET}"
         ;;
   esac
}

#
# Three assumptions are being made in the performance of this function.
# First, that the downloaded font file is in ZIP format; second, that
# the font files are in a directory only one level down; and, lastly,
# that the fonts are being fetched from the fonts.google foundry.
#
# Parameter explanation:
#    The native font file name
#       (eg, IBMPlexMono-Regular.ttf)
#    The font name
#       (eg, IBM Plex Mono)
#    The URL to the direct download of the font
#       (eg, https://fonts.google.com/download?family=IBM%20Plex%20Mono)
#    The font’s installer file name
#       (eg, IBM_Plex_Mono.zip)
#    The target folder into which the fonts will be uncompressed
#       (eg, IBM_Plex_Mono)
#
# Example usage:
#    install_typeface \
#       "CourierPrime-Regular.ttf" \
#       "Courier Prime" \
#       "https://fonts.google.com/download?family=Courier%20Prime" \
#       "Courier_Prime.zip" \
#       "Courier_Prime"
#
function install_typeface () {
   if [[ -e "$HOME/Library/Fonts/$1" ]]; then
      print_msg "warn"  "$2 is already installed. Skipping..."
   else
      print_msg "log" "Downloading the $2 typeface..."
      curl "$3" -o "$4"

      print_msg "log" "Unzipping the $2 typeface..."
      unzip "$4" -d "$5"

      print_msg "log" "Installing the $2 typeface into Font Book..."
      mv "$5"/*.ttf "$HOME/Library/Fonts/"

      print_msg "log" "Removing un-needed $5..."
      rm -fr "$5"

      print_msg "log" "Removing un-needed $4 file..."
      rm -fr "$4"
   fi
}

#
# Fetches software via cURL and requires three parameters:
#    The name of the software program (eg, Zoom)
#    The name of the installer (eg, Zoom.pkg)
#    The URL of the installer formatted for cURL calls (eg, https://cdn.zoom.us/prod/5.9.3.4239/Zoom.pkg)
#
# Example usage:
#    install 'Zoom' 'Zoom.pkg' 'https://cdn.zoom.us/prod/5.9.3.4239/Zoom.pkg'
#
function install () {
   INSTALLER=$2

   while true
      do
         print_msg "log" " Would you like to install $1?"
         read -p "${BG_YELLOW}${BLACK}${BOLD}>>>>  [y]es or [n]o. ${RESET}" -n 1 -r RESPONSE

         case $RESPONSE in
            [yY]* )
               print_msg "log" "Downloading $1..."
               curl "$3" --compressed -o "$2"

               print_msg "log" "Opening $1... "
               open "$2"

               print_msg "log" "Complete the installation, decide if you’d like to remove"
               print_msg "log" "the installer (in the next step), then return to this script."

               while true
                  do
                     print_msg "log" "Would you like me to remove $INSTALLER?"
                     read -p "${BG_YELLOW}${BLACK}${BOLD}>>>>  [y]es or [n]o. ${RESET}" -n 1 -r REMOVE_RESPONSE

                     case $REMOVE_RESPONSE in
                        [yY]* )
                           print_msg "log" "Removing $INSTALLER and continuing."
                           rm -fr "$INSTALLER"

                           break;;

                        [nN]* )
                           print_msg "log" "Keeping $INSTALLER and continuing"

                           break;;

                        * )
                           print_msg "log" "${BG_YELLOW}${BLACK}${BOLD}>>>>  Please choose whether you’d like to remove $INSTALLER. [y]es, [n]o, or [q]uit. ${RESET} ";;
                     esac
               done

               break;;

            [nN]* )
               break;;

            * )
               print_msg "warn" "${BG_YELLOW}${BLACK}${BOLD}>>>>  Please choose. Install the $1? [y]es, [n]o, or [q]uit. ${RESET} ";;
         esac
   done
}

function install_configuration_file() {
   if [[ -e "$HOME/$1" ]]; then
      if [[ -e "$HOME/.backup$1" ]]; then
         print_msg "log" "$1 and .backup$1 exist."
         print_msg "log" "Nothing to install. Continuing..."
      else
         print_msg "log" "$1 file exists."
         pause

         print_msg "log" "Renaming to .backup$1..."
         mv -v "$HOME/$1" "$HOME/.backup$1"

         print_msg "log" "Downloading $1..."
         curl -O "$2$1"

         if [[ -e "$1" ]]; then
            print_msg "log" "$1 downloaded successfully."

            print_msg "log" "Installing $1..."
            mv -v "$1" "$HOME/"

            if [[ -e "$1" ]]; then
               print_msg "warn" "$1 was not successfully installed. Please investigate, then continue."
               pause
            else
               print_msg "log" "$1 was installed successfully."
            fi
         fi
      fi
   else
      print_msg "log" "Downloading $1..."
      curl -O "$2"

      if [[ -e "$1" ]]; then
         print_msg "log" "$1 downloaded successfully."

         print_msg "log" "Installing $1..."
         mv -v "$1" "$HOME/"

         if [[ -e "$1" ]]; then
            print_msg "warn" "$1 was not successfully installed. Please investigate, then continue."
            pause
         else
            print_msg "log" "$1 was installed successfully."
         fi
      fi
   fi
}

function pause () {
   if [[ -n $2 ]]; then
      echo "";
   fi

   echo -e "${BG_YELLOW}${BLACK}${BOLD}>>>>  $1 ${RESET}"
   echo -e "${BG_YELLOW}${BLACK}${BOLD}>>>> ${RESET}"

   read -r -p "${BG_YELLOW}${BLACK}${BOLD}>>>>  Continue? [Yy] ${RESET} " -n 1 -r

   if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      print_msg "error" "Exiting..." true

      exit 1;
   fi
}
